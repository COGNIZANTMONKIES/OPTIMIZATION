####################################################################################
####################################################################################
      Loops
####################################################################################
####################################################################################

************************************************************************************
      Outline
************************************************************************************
* Pattern Recognition
* for loop anatomy
* for loop tweaking
* while loop anatomy
* while loop tweaking
* simple rated loops
* intermediate rated loops
* advanced rated loops
************************************************************************************


* Pattern Recognition

	Patterns are everywhere. Whether you recognize it or not. 
	Pattern recognition, inquisition, creativity, wisdom and a 
	beginners mindset are keys to successful optimization. 
	Universities claim humans ability to recognize patterns
	is not teachable, but only within. In other words they think
	a persons aptitude is constant. In my experience, people
	just have an underutilized brain muscle that needs conditioning.
	At first by themselves they may never recognize patterns until 
	you push the snowman down the mountain. The snowman grows in
	size and eventually "explodes" after impact with a tree. 
	Beware, sleepless nights I've had because I see patterns 
	everywhere. It's beautiful and ugly. Your forehead will burn
	once these pattern recognition brain muscles daemon.
	
	In programming, your pattern recognition skills are 
	most noticeable by writing loops or logarithmic algorithms or constant algorithms. 
	Loops repeat code along with the modifications of the repeated code.
	
	Simple to more complex patterns will be demonstrated.
	Follow along with each exercise, find each pattern or patterns
	before looking up answers. Exercises will subjectively progress
	from basic to harder.
	
	Sample 0)
	
		Outputs
		
			0
			1
			2
			3
			0
			1
			2
			3
			0
			1
			2
			3
			
		Solution Explained
		
			0 A
			1 B
			2 C
			3 D
			0 A
			1 B
			2 C
			3 D
			0 A
			1 B
			2 C
			3 D
			
			A = 0
			B = 1
			C = 2
			D = 3
			
			(A,B,C,D) repeats 3 times
			
			JavaScript Implementations
				
				// implementation 0
				
				for (let j = 0; j < 3; j++) {
					for (let i = 1; i < 5; i++) console.log(i);
				}
				
				// implemetation 1 // loop broken up for optimization reasons
				
				for (let j = 0; j < 3; j++) {
					console.log(0);
					console.log(1);
					console.log(2);
					console.log(3);
				}
				
	Sample 1)
		
		Outputs
		
			1
			1
			2
			1
			2
			3
			1
			2
			3
			4
		
		Solution
			
			1 A
			1 A
			2 B
			1 A
			2 B
			3 C
			1 A
			2 B 
			3 C
			4 D
			
			A = 1
			B = 2
			C = 3
			D = 4
			
			(A,B,C,D) repeats by divisable increments (downward staircases)
			
			in other words
			
			(A)
			(A,B)
			(A,B,C)
			(A,B,C,D)
			
			JavaScript Implementations
			
				// implementation 0
				
				for (let j = 1; j < 4; j++) {
					for (let i = 1; i <= j; i++) {
						console.log(i);
					}
				}
				
		
	Exercise 0)
	
		Outputs
		
			0
			1
			2
			0
			1
			2
			0
			1
			2
			
		Solution
		
	Exercise 1)
		Outputs
		
			01
			012
			01
			012
			01
			012
		
		Solution
	Exercise 2)
		Outputs
			
			01
			012
			0123
			012
			01
			012
			0123
			012
			01
			012
			0123
			012
			01
			012
			0123
			012
		
		Solution
	Exercise 3)
		Outputs
		
			5
			4
			3
			4
			3
			2
			3
			2
			1
			
		Solution
	Exercise 4)
		Outputs

			1234
			123
			12
			1
			12
			123
			1234
			123
			12
			1
			12
			123
			1234
			123
			12
			1
			12
			123
			1234

		Solution
	Exercise 5)
	
		Outputs
		
			12321
			23432
			34545
			45654
			56765
			67876
			78987
			
		Solution
	
	Exercise 6)
	
 		Outputs
		
			123
			321
			234
			432
			345
			543
		
		Solution
		
	Exercise 7)
	
		Outputs
			
			3
			2
			1
			6
			5
			4
			9
			8
			7
			
		Solution
		
		
	Exercise 8)
	
		Outputs
		
			0,0
			0,1
			0,2
			1,0
			1,1
			1,2
			3,0
			3,1
			3,2
		
		Solution
		
	Exercise 9)
	
		Outputs
		
			0,0,0
			0,0,1
			0,1,0
			0,1,1
			1,0,0
			1,0,1
			1,1,0
			1,1,1
			
		Solution
		
	Exercise A)
		Outputs
		Solution
	Exercise B)
		Outputs
		Solution
	Exercise C)
		Outputs
		Solution
	Exercise D)
		Outputs
		Solution
	Exercise E)
		Outputs
		Solution
	Exercise F)
		Outputs
		Solution
	Exercise G)
		Outputs
		Solution
	Exercise H)
		Outputs
		Solution
	Exercise I)
		Outputs
		Solution
	Exercise J)
		Outputs
		Solution
	Exercise K)
		Outputs
		Solution
	Exercise L)
		Outputs
		Solution
	Exercise M)
		Outputs
		Solution
	Exercise N)
		Outputs
		Solution
	Exercise O)
		Outputs
		Solution
	Exercise P)
		Outputs
		Solution
	Exercise Q)
		Outputs
		Solution
	Exercise R)
		Outputs
		Solution
	Exercise S)
		Outputs
		Solution
	Exercise T)
		Outputs
		Solution
	Exercise U)
		Outputs
		Solution
	Exercise V)
		Outputs
		Solution
	Exercise W)
		Outputs
		Solution
	Exercise X)
		Outputs
		Solution
	Exercise Y)
		Outputs
		Solution
	Exercise Z)
		Outputs
		Solution
	
* for loop anatomy

	for (initial; limiter; incrÃ©menter) codeToRepeat;

	Initial	         is executed once
	Limiter              is executed before each codeToRepeat
	incrementer     is executed after    each codeToRepeat


	In raw code this is what happens sequentially

	Code Input 

		for (let i = 0; i < 3; i++) console.log(i); 

	Code Output

		let i = 0;
		if (i < 3) console.log(i);		// logs I to console
		else break;
		i++
		if (i < 3) console.log(i);		// logs I to console
		else break;
		i++
		if (i < 3) console.log(i);		// logs I to console
		else break;
		i++
		if (i < 3) console.log(I);		// skips this
		else break;				// breaks away

	The normal way of programming follows those named syntax positions.
	However, in some languages like JavaScript, the incrementer can be left blank.

	Code Input

		let i = 0;
		console.log(i);
		for (let i = i; i++ ^ 3; ) console.log(i); 

	Code Output

		let i = 0;
		console.log(i);				// logs I to console
	
		if (i ^ 3) console.log(i);		// logs I to console
		else break

		if (i ^ 3) console.log(i);		// logs I to console
		else break

		if (i ^ 3) console.log(i);		// logs I to console
		else break
		
* for loop tweaking
	/*JavaScripts Documented Loop ... purely numbers*/

		for (let i=0;i<100;i++) {console.log(i);}

	/*OPTIMIZED Loops*/

	// Forwards
	
		let i;

		for (i=0;100^i++;)      {console.log(i);}
	
	// Backwards

		let i;
		for (i=100;--i;)	{console.log(i);}
		console.log(0);

	/*JavaScripts Documented Loop ... hash access*/

		let list = ['a','b','c','d','e'];

		for (let i=0;i<list.length;i++)	{console.log(list[i]);}


	// Forwards 
		// warning ... any falsy value will cut loop short
		let list = ['a','b','c','d','e'];
	
		let i;

		for (i=false; console.log((i=arr.shift())),i; i++)


	// Backwards

		// warning same as above

		let list = ['a','b','c','d','e'];

		let i;

		for (i=false; console.log((i=arr.pop())),i;) 



	/*More Ways to loop*/

	// Forwards

	instead of (   i <   lim   )

	do 	   (   i !== lim   )

	do         (   i ^   lim   )


	// Backwards

	instead of (   i >   lim   ) 

	do 	   (   i !== lim   )

	do         (   --i         ) then lowest i because ...

	do         (   i ^   lim   ) then lowest i because it never exes during loop


	lets say you only had to loop 5 times

	then  for (let i=32; i>>1;)

	let's say you only had to loop 31 times     

	then  for (let i=2**32; i>>1;)


	/*TWEAKING LOOPS*/

	Loops demonstrated above break ordinary/routine habits.
	Normally 3 placeholders are used. 

	normal syntax:     for (<init>;<limit:boolean>;<stepper:void>;) {<block>}


	leveraged syntax:  for (<init>;<limit:boolean>;)



	Point outs.


	Within the <limit> syntax, take advantage of comma expressions;

	i.e.     i = console.log('hi'), 3;   // prints 'hi' and i equals 3.


	* comma expressions reduce execution time by squeezing expressions before 
	  a new round starts.



	imagine position a = <init>
	imagine position b = <limit>
	imagine position c = <stepper>



	a .. b .. c are there own invoked function positions.
	All must be invoked first before the statemens inside evaluate.



	Think of a .. b .. c as 5 bits each.


	Minimum 5*3=15 bits used. 

	And each statement is 2bits each.



	... = statements

	a:(5+ ...)   +     b:(5+ ...)   +   c:(5+ ...

	_____________________________________________


	Now you see why squeezing them together is better.


	Because you lose 5 every for one less invoke.


* while loop anatomy
* while loop tweaking
* simple rated loops
* intermediate rated loops
* advanced rated loops







******************************************************************************
******************************************************************************
