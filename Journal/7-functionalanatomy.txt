******************************************************************
******************************************************************
      Functional Anatomy
******************************************************************
******************************************************************
* anatomy point of views
* optimizing validations in loops
* eliminating redundant validations
******************************************************************


* anatomy point of views

  Normal Presented Anatomy
    
    function <name> (<params>) { 
      <code> 
    }
    
  The Real Anatomy (Hackers Point of View)
  
    function <name> (<params>) {
      <validations>
      <block>
    }
  
  Notice <code> replaced with <validations> and <block>.
  
  <validations> assert input data is non malicious, within ranges,
  and are appropriate datatypes.
  
  <block> is the functions intended code to execute.
  
* optimizing validation loops

    The problem with the functional anatomy is the sequential ordering.
    Singular inputs like numbers and booleans are fine to use the functional anatomy.
    Tho plural datatypes like strings, objects, and arrays need an adjustment to that model.

    The function arrToStr below is a prime example of the innefficiencies posed when
    validating input data. The algorithms weakness is that it loops over the array
    twice. First loop asserts datatype. Second loop concatenates. Another weakness of
    joinStr is the memory usage. An existing array followed by a matching string
    is no bueno unless for any reason the program required it.
  
    function arrToStr(arr) {
     
      // validation
      
      Array.isArray(arr)                               || (()=>{throw new Error()})() 
      arr.every((e=>{ return typeof e === "string" })) || (()=>{throw new Error()})()
      
      // block
      
      let str = "";
      arr.forEach((e)=>{ str += e });

      return str;
    }
     
    Function arrToStr_optimized uses little CPU and Memory. It traverses the
    array input one time while deleting the indexed value but transfers the
    value to a str. This function is safe from falsy values in the array.
    Notice that the repeated code block was compensated by the loops
    limiter position. 
     
    function arrToStr_optimized(arr) {
      
      // validation
      
      Array.isArray(arr)                               || (()=>{throw new Error('not array')})() 
      
      // block
      let len = arr.length; // the initial length of arr
      let i;                // iterator
      let str = "";         // array converted string
      let s = "";
      for (
            i = len+1; 
            (i--) && (typeof (s = arr.shift()) === "string"); 
            str += s
      ) // codeBlocked ignored and represented in loops placeholders
      
      if (i ^ 0) throw new Error('i not eq 0'); 
      
      return str
    }
    
    
    
    
    
    
  
  
  
  


