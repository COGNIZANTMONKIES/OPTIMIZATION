******************************************************************
******************************************************************
      Functional Anatomy
******************************************************************
******************************************************************
* anatomy point of views
* optimizing validations in loops
* eliminating redundant validations
******************************************************************


* anatomy point of views

  Normal Presented Anatomy
    
    function <name> (<params>) { 
      <code> 
    }
    
  The Real Anatomy (Hackers Point of View)
  
    function <name> (<params>) {
      <validations>
      <block>
    }
  
  Notice <code> replaced with <validations> and <block>.
  
  <validations> assert input data is non malicious, within ranges,
  and are appropriate datatypes.
  
  <block> is the functions intended code to execute.
  
* optimizing validation loops

    The problem with the functional anatomy is the sequential ordering.
    Singular inputs like numbers and booleans are fine to use the functional anatomy.
    Tho plural datatypes like strings, objects, and arrays need an adjustment to that model.

    The function arrToStr below is a prime example of the innefficiencies posed when
    validating input data. The algorithms weakness is that it loops over the array
    twice. First loop asserts datatype. Second loop concatenates. Another weakness of
    arrToStr is the memory usage. An existing array followed by a matching string
    is no bueno unless for any reason the program required it. Only one benefit from
    this approach no memory writes waisted if any invalid inputs.
  
    function arrToStr(arr) {
     
      // validation
      
      Array.isArray(arr)                               || (()=>{throw new Error()})() 
      arr.every((e=>{ return typeof e === "string" })) || (()=>{throw new Error()})()
      
      // block
      
      let str = "";
      arr.forEach((e)=>{ str += e });

      return str;
    }
     
    Function arrToStr_optimized uses little CPU and Memory. It traverses the
    array input one time while deleting the indexed value but transfers the
    value to a str. This function is safe from falsy values in the array.
    Notice that the repeated code block was compensated by the loops
    limiter position. We can call this approach "on the fly validations"
    to avoid looping twice and write to memory as you go. After all, it
    takes a split second to delete used spaces.
     
    function arrToStr_optimized(arr) {
      
      // validation
      
      Array.isArray(arr)                               || (()=>{throw new Error('not array')})() 
      
      // block
      let len = arr.length; // the initial length of arr
      let i;                // iterator
      let str = "";         // array converted string
      let s = "";
      for (
            i = len+1; 
            (i--) && (typeof (s = arr.shift()) === "string"); 
            str += s
      ) // codeBlocked ignored and represented in loops placeholders
      
      if (i ^ 0) throw new Error('i not eq 0'); 
      
      return str
    }
    
    Summing an array with unknown datatypes inputs and unsorted values.
    Again, this approach is inneficient as it loops the array twice.
    JavaScript developers have been known to rely on hardware speed.
    That is bad practice. It's one thing for json lists to contain
    10 or less indexes in there lists. It's another problem when
    the returned database queries are 100s to 1000s to 10000s and beyond.
    
    function sumArr(arr) {
      
      // validations
      
      Array.isArray(arr) || (()=>{throw new Error()})();
      arr.every((e)=>{ return typeof e === "number" });
      
      // block
      
      let sum = 0;
      
      arr.forEach((e)=>{ sum += e; });
      
      return sum;
    }
    
    Below function sumArr_optimized is concious of ensuring
    the indexed values are numbers. Not only does it assert
    proper inputs, it kills two birds with one stone because
    accessing an arrays values requires the iteration number
    to be an integer of 0 -> array index limit. Thats why the
    if statement checks for i > -1 to ensure no loop was terminated
    early from an improper datatype.
    
    function sumArr_optimized(arr) {
    
      // validations
      
      Array.isArray(arr) || (()=>{throw new Error()})();
      
      // block
      
      let sum = 0;
      let i;
      for (
            i = arr.length-1; 
            typeof arr[i] === "number"; 
            sum+=arr[i--]
      ) ;
      
      (i > -1) && (()=>{throw new Error()})()
      
      return sum;
    }
    
    
    
    
* eliminating redundant validations

  Aiding in debugging and securing code has cluttered codebases
  with unwanted and unnoticed data input assertions. The main intention
  of writing functions is to be independent from other code. Yet these functions
  are unaware of it's implemented positons. In other words, code is written statically
  and needs to be dynamic. How you might ask to code dynamically? 
  First a universal componentized functional anatomy agreement must union. 
  The componentized anatomy point of view I propose has worked in my recent projects.
  It's an eye opener to the code patterns presented everywhere in programming. These concepts are nothing
  new but scavenged into a unified model to give clarity about programming functions.
  
  
  const dynamicFunctionAnatomy = Object.freeze(Object.assign(
      function() {
            dynamicFunctionAnatomy.defaults(arguments);
            dynamicFunctionAnatomy.validate(arguments);
            dynamicFunctionAnatomy.block   (arguments);
      },
      {
            defaults: function(){},
            validate: function(){},
            block   : function(){}
      }
  ));
  
  the anonymous function calls the 3 

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  
  
  
  


