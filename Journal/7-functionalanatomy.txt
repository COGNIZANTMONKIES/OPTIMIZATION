******************************************************************
******************************************************************
      Functional Anatomy
******************************************************************
******************************************************************
* anatomy point of views
* optimizing validations in loops
* eliminating redundant validations
******************************************************************


* anatomy point of views

  Normal Presented Anatomy
    
    function <name> (<params>) { 
      <code> 
    }
    
  The Real Anatomy (Hackers Point of View)
  
    function <name> (<params>) {
      <validations>
      <block>
    }
  
  Notice <code> replaced with <validations> and <block>.
  
  <validations> assert input data is non malicious, within ranges,
  and are appropriate datatypes.
  
  <block> is the functions intended code to execute.
  
* optimizing validation loops

    The problem with the functional anatomy is the sequential ordering.
    Singular inputs like numbers and booleans are fine to use the functional anatomy.
    Tho plural datatypes like strings, objects, and arrays need an adjustment to that model.

    The function arrToStr below is a prime example of the innefficiencies posed when
    validating input data. The algorithms weakness is that it loops over the array
    twice. First loop asserts datatype. Second loop concatenates. Another weakness of
    arrToStr is the memory usage. An existing array followed by a matching string
    is no bueno unless for any reason the program required it.
  
    function arrToStr(arr) {
     
      // validation
      
      Array.isArray(arr)                               || (()=>{throw new Error()})() 
      arr.every((e=>{ return typeof e === "string" })) || (()=>{throw new Error()})()
      
      // block
      
      let str = "";
      arr.forEach((e)=>{ str += e });

      return str;
    }
     
    Function arrToStr_optimized uses little CPU and Memory. It traverses the
    array input one time while deleting the indexed value but transfers the
    value to a str. This function is safe from falsy values in the array.
    Notice that the repeated code block was compensated by the loops
    limiter position. 
     
    function arrToStr_optimized(arr) {
      
      // validation
      
      Array.isArray(arr)                               || (()=>{throw new Error('not array')})() 
      
      // block
      let len = arr.length; // the initial length of arr
      let i;                // iterator
      let str = "";         // array converted string
      let s = "";
      for (
            i = len+1; 
            (i--) && (typeof (s = arr.shift()) === "string"); 
            str += s
      ) // codeBlocked ignored and represented in loops placeholders
      
      if (i ^ 0) throw new Error('i not eq 0'); 
      
      return str
    }
    
    
    In the example below. We will not use JS builtin Number function to convert
    any valid value to a number datatype. Function strToNum exhibits replicable
    problems arrToStr presented. It loops twice over the list. 
    
    
    function strToNum(str) {
      
      // validations
      
      typeof str === "string" || (()=>{throw new Error()})();
      !str.match(/[^0-9]/)    || (()=>{throw new Error()})(); 
      
      // block
 
      let refs = {
            "0":0,"1":1,"2":2,"3":3,"4":4,
            "5":5,"6":6,"7":7,"8":8,"9":9
      };
 
      let num = 0;
      let i;
      for (i = str.length-1; i; i--) num += refs[str[i]] * Math.pow(10,(str.length - (i + 1)));
      
      num += refs[str[0]] * Math.pow(10,(str.length - 1));
      
      return num;
    }
    
    Function strToNum_optimized solution loops through the string validating information
    first, then looking up information. Instead of using regex to match against numbers,
    the variable refs table is relied upon for an indexed value of a number or undefined.
    
    function strToNum_optimized(str) {
      
      // validations
      
      typeof str === "string" || (()=>{throw new Error()})();
      
      // block
 
      let refs = {
            "0":0,"1":1,"2":2,"3":3,"4":4,
            "5":5,"6":6,"7":7,"8":8,"9":9
      };
 
      let num = 0;
      let i;
      
      for (
            i = str.length-1; 
            i; 
            i--
      ) {
            num += refs[str[i]] * Math.pow(10,(str.length - (i + 1)));
      }
      
      num += refs[str[0]] * Math.pow(10,(str.length - 1));
      
      return num;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  
  
  
  


